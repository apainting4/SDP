//including headers
#include "FEHUtility.h"
#include "FEHLCD.h"
#include "FEHImages.h"
#include "FEHKeyboard.h"
#include <FEHRandom.h>
#include <stdio.h>
#include "FEHSound.h"

//Creating a class so all the data can be shared
class Stats {
public:
//Defining all the functions as public
void MainMenu(); 
void Touch(int a, int b);
void Game(int d);
void GameOver(int *t);
void Difficulty();
void writeleaderboard(int *ew,int *mw,int *hw);
void easyleaderboard(int e,int *ew);
void medleaderboard (int m, int *mw);
void hardleaderboard (int h, int *hw);
private:
//Declaring variables as private
int medw,hardw,easyw;
int easywinner=0;
int medwinner=0;
int hardwinner=0;
int time=0;
int difficulty;
//Declaring a variable of class Stats
}funccall;



struct Robot {
    int xpos;
    int ypos;

    //bounding boxes for collisions
    int topy;
    int boty;
    int leftx;
    int rightx;

    //rest bool condition
    bool reset;
};


void Stats::Game(int d)
{
    //Clearing screen for game
    LCD.Clear();
    LCD.Update();
    //Initializing start time
    int starttime=TimeNow();
    //Finding seconds passed
    time=TimeNow()-starttime;
    //Displaying seconds passed
   LCD.SetFontColor(WHITE);
   LCD.WriteAt(time,15,215); 

       int gameover = false;
    
    //declare the robots
    struct Robot robot1;
    struct Robot robot2;
    struct Robot robot3;


    //brutus stuff

            //brutus position
            int positionx = 152;
            int positiony = 185;
            
            //brutus position variables
            int right = 0;
            int rightcount = 0;

            //brutus position varibles
            int left = 0;
            int leftcount = 0;

            //brutus bounds
            int brutus_topy = positiony - 15;
            int brutus_boty = positiony + 15;
            int brutus_left = positionx - 10;
            int brutus_right = positionx + 10;

            //collisons
            bool brutuscollision;

    //initial robot positions
    robot1.xpos = 111;
    robot1.ypos = -200;
    robot1.leftx = robot1.xpos - 20;
    robot1.rightx = robot1.xpos + 20;
    robot1.topy = robot1.ypos - 15;
    robot1.boty = robot1.ypos + 15;

    robot2.xpos = 111;
    robot2.ypos = -300;
    robot2.leftx = robot2.xpos - 20;
    robot2.rightx = robot2.xpos + 20;
    robot2.topy = robot2.ypos - 15;
    robot2.boty = robot2.ypos + 15;

    robot3.xpos = 111;
    robot3.ypos = -400;
    robot3.leftx = robot3.xpos - 20;
    robot3.rightx = robot3.xpos + 20;
    robot3.topy = robot3.ypos - 15;
    robot3.boty = robot3.ypos + 15;

    //stuff
    //road ys
    int road1y = 0;
    int road2y = -240;

    //highstreety 
    int high1y = -2726;
    int high2y = -5692;

    int ahigh1y = -2726;
    int ahigh2y = -5692;



    
    //difficulty
   difficulty=d;

    //path random variable
    int pathrand;

    //collision variable
    bool collision = true; 

        // Declares an image for a unicorn

    FEHImage road1; // Screenshot from Google Earth
    // Open the image
    road1.Open("road.png");

    FEHImage road2; // Screenshot from Google Earth
    // Open the image
    road2.Open("road.png");

    FEHImage brutus; // AI generated image from chat gpt
    // Open the image
    brutus.Open("brutus.png");  
    // Draw a unicorn in the top left corner
    FEHImage robot; //AI generated image from chat gpt
    // Open the image
    robot.Open("finalrobot.png");
    // Draw a unicorn in the top left corner

    
    FEHImage highstreet1; // Screenshot from Google Earth
    // Open the image
    highstreet1.Open("LONGWAYhighstreet.png");

    FEHImage highstreet2; // Screenshot from Google Earth
    // Open the image
    highstreet2.Open("LONGWAYhighstreet.png");

    FEHImage ahighstreet1; // Screenshot from Google Earth
    // Open the image
    ahighstreet1.Open("aLONGWAYhighstreet.png");

    FEHImage ahighstreet2; // Screenshot from Google Earth
    // Open the image
    ahighstreet2.Open("aLONGWAYhighstreet.png");

    highstreet1.Draw(-9, -2726);
    highstreet1.Draw(-9, -5692);

    ahighstreet1.Draw(229, -2726);
    ahighstreet1.Draw(229, -5692);



    road1.Draw(110, 0);
    road2.Draw(110,-240);
    brutus.Draw(positionx, 185);
    LCD.Update();
    //Sleep(1000);

     // Create and play a background music file
    FEHSound backgroundMusic("Minion March.wav");
    backgroundMusic.setVolume(0.5);
    backgroundMusic.play();
    
    

    while(gameover == false)
    {
    

    
    
    /*
    brutus.Draw(152, 185);
    brutus.Draw(116, 185);
    brutus.Draw(188, 185);
    
    
    robot.Draw(183, 100);
    robot.Draw(111, 100);
    robot.Draw(149, 100);
    */

// move right position function
    if(positionx < 188)
        {
        if(right != 1)
        {
        if(Keyboard.isPressed({KEY_D}))
            {
            right = 1;
            }
        }
        }
    if ((right) == 1)
        {
        if((rightcount) <  36)
                {
                positionx += 6;
                rightcount += 6;
                }
        
        else
                {
                right = 0;
                rightcount = 0;
                } 
        }


        Sleep(8);

//move left function
if(positionx > 116)
        {
        if(left != 1)
        {
        if(Keyboard.isPressed({KEY_A}))
            {
            left = 1;
            }
        }
        }
    if ((left) == 1)
        {
        if((leftcount) < 36)
                {
                positionx -= 6;
                leftcount += 6;
                }
        
        else
                {
                left = 0;
                leftcount = 0;
                } 
        }

    // draw the road
    high1y += difficulty;
    high2y += difficulty;

    ahigh1y += difficulty;
    ahigh2y += difficulty;

    road1y += difficulty;
    road2y += difficulty;

    road1.Draw(110, road1y);
    road2.Draw(110, road2y);

    highstreet1.Draw(-9, high1y);
    highstreet2.Draw(-9, high2y);

    ahighstreet1.Draw(229, ahigh1y);
    ahighstreet2.Draw(229, ahigh2y);


    if(road1y >= 240){
        road1y = -240;
    }
    if(road2y >= 240){
        road2y = -240;
    }

    if(high1y >= 2966){
        high1y = -2966;
    }
    if(high2y >= 2966){
        high2y = -2966;
    }

    if(ahigh1y >= 2966){
        ahigh1y = -2966;
    }
    if(ahigh2y >= 2966){
        ahigh2y = -2966;
    }
    
//robot 1

    //set the robot back to above the 
    if(robot1.ypos > 260) //if the robot goes off the screen
    {
             
                    do{
                    robot1.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200)   moved up above scree
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand){

                    case 1:
                        robot1.xpos = 111;//one of 3 xpos 
                    break;

                    case 2:
                        robot1.xpos = 149;//one of 3 xpos 
                    break;

                    case 3:
                        robot1.xpos = 183;//one of 3 xpos 
                    break;


                    }   
                    //check to make sure the robot is not interfering with another robot
                    robot1.leftx = robot1.xpos - 20;
                    robot1.rightx = robot1.xpos + 20;
                    robot1.topy = robot1.ypos - 15;
                    robot1.boty = robot1.ypos + 15;

                        collision = false;

                        // robot1 vs robot2
                        if (!(robot1.rightx < robot2.leftx  || robot1.leftx  > robot2.rightx || robot1.boty   < robot2.topy   || robot1.topy   > robot2.boty)){collision = true;}

                        // robot1 vs robot3
                        if (!(robot1.rightx < robot3.leftx  || robot1.leftx  > robot3.rightx || robot1.boty   < robot3.topy   || robot1.topy   > robot3.boty)){collision = true;}


                    
        } while(collision == true);
        collision = true;
        
    }

//robot 2
 
    if(robot2.ypos > 260) //if the robot goes off the screen
    {
    
                    do{
                    robot2.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200)   moved up above scree
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand)
                        {

                        case 1:
                            robot2.xpos = 111;//one of 3 xpos 
                        break;

                        case 2:
                            robot2.xpos = 149;//one of 3 xpos 
                        break;

                        case 3:
                            robot2.xpos = 183;//one of 3 xpos 
                        break;

                        }   
                    //check to make sure the robot is not interfering with another robot
                    robot2.leftx = robot2.xpos - 20;
                    robot2.rightx = robot2.xpos + 20;
                    robot2.topy = robot2.ypos - 15;
                    robot2.boty = robot2.ypos + 15;

                        collision = false;

                        // robot2 vs robot1
                        if (!(robot2.rightx < robot1.leftx  || robot2.leftx  > robot1.rightx || robot2.boty   < robot1.topy   || robot2.topy   > robot1.boty)){collision = true;}

                        // robot2 vs robot3
                        if (!(robot2.rightx < robot3.leftx  || robot2.leftx  > robot3.rightx || robot2.boty   < robot3.topy   || robot2.topy   > robot3.boty)){collision = true;}

 
                    
        } while(collision == true);
        collision = true;
        
    }

//robot 3

    //set the robot back to above the 
    if(robot3.ypos > 260) //if the robot goes off the screen
    {
                    
                    
                    
                    
                    do{
                    robot3.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200)   moved up above scree
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand){

                    case 1:
                        robot3.xpos = 111;//one of 3 xpos 
                    break;

                    case 2:
                        robot3.xpos = 149;//one of 3 xpos 
                    break;

                    case 3:
                        robot3.xpos = 183;//one of 3 xpos 
                    break;


                    }   
                    //check to make sure the robot is not interfering with another robot
                    robot3.leftx = robot3.xpos - 20;
                    robot3.rightx = robot3.xpos + 20;
                    robot3.topy = robot3.ypos - 15;
                    robot3.boty = robot3.ypos + 15;

                        collision = false;

                        // robot3 vs robot2
                        if (!(robot3.rightx < robot2.leftx  || robot3.leftx  > robot2.rightx || robot3.boty   < robot2.topy   || robot3.topy   > robot2.boty)){collision = true;}

                        // robot3 vs robot1
                        if (!(robot3.rightx < robot1.leftx  || robot3.leftx  > robot1.rightx || robot3.boty   < robot1.topy   || robot3.topy   > robot1.boty)){collision = true;}


                    
        } while(collision == true);
        collision = true;
        
    }

    //check for brutus collisions

    robot1.leftx = robot1.xpos - 20;
    robot1.rightx = robot1.xpos + 20;
    robot1.topy = robot1.ypos - 15;
    robot1.boty = robot1.ypos + 15;

    robot2.leftx = robot2.xpos - 20;
    robot2.rightx = robot2.xpos + 20;
    robot2.topy = robot2.ypos - 15;
    robot2.boty = robot2.ypos + 15;

    robot3.leftx = robot3.xpos - 20;
    robot3.rightx = robot3.xpos + 20;
    robot3.topy = robot3.ypos - 15;
    robot3.boty = robot3.ypos + 15;

    brutus_topy = positiony - 15;
    brutus_boty = positiony + 15;
    brutus_left = positionx - 10;
    brutus_right = positionx + 10;

    brutuscollision = false;

                        if (!(brutus_right < robot1.leftx  || brutus_right  > robot1.rightx || brutus_boty   < robot1.topy   || brutus_topy   > robot1.boty)){brutuscollision = true;}

                        // robot3 vs robot2
                        if (!(brutus_right < robot2.leftx  || brutus_right  > robot2.rightx || brutus_boty   < robot2.topy   || brutus_topy   > robot2.boty)){brutuscollision = true;}

                        // robot3 vs robot1
                        if (!(brutus_right < robot3.leftx  || brutus_right  > robot3.rightx || brutus_boty   < robot3.topy   || brutus_topy   > robot3.boty)){brutuscollision = true;}
        

    


    ///advance robots
    
    robot.Draw(robot1.xpos, robot1.ypos);
    robot1.ypos += difficulty;

    robot.Draw(robot2.xpos, robot2.ypos);
    robot2.ypos += difficulty;

    robot.Draw(robot3.xpos, robot3.ypos);
    robot3.ypos += difficulty;

    brutus.Draw(positionx, 185);

    if(brutuscollision == true){
         gameover = true;
         backgroundMusic.pause();
      //Updating the high score based on difficulty level chosen
       if(difficulty==6)
      {
        
        funccall.easyleaderboard(time,&easyw);
      }
      else if(difficulty==8)
      {
       
        funccall.medleaderboard(time,&medw);
      }
      else if(difficulty==10)
      {
        
        funccall.hardleaderboard(time,&hardw);
      }
      //Displaying game over screen
      funccall.GameOver(&time);
    }


    //Robot
    //  +15 x  ____ + 20 y
    //LCD.FillRectangle(120, 40, 30, 40);

    //LCD.SetFontColor(RED);



    //Brutus
    //  +10 x  ____ + 15 y
    //LCD.FillRectangle(125, 100, 20, 30);
    
    
    
    
    
    //updating timer
    LCD.SetFontColor(BLACK);
    LCD.FillRectangle(10, 210, 25, 20);
    time=TimeNow()-starttime;
   LCD.SetFontColor(WHITE);
   LCD.WriteAt(time,15,215); 
    
    LCD.Update();
    Sleep(10);
}
}
//defining GameOver function
void Stats::GameOver(int *t)
{
    FEHSound vineboom("vine-boom.wav");
    vineboom.setVolume(5);
    vineboom.play();
    LCD.Clear();
    LCD.SetFontColor(WHITE);
    LCD.SetFontScale(2);
    LCD.WriteAt("GAME OVER",50,25);
    //displaying players time that was passed to the function
    LCD.SetFontScale(1);
    LCD.WriteAt("Player's Time:",70,80);
    LCD.WriteAt(*t,70,100);
    LCD.WriteAt("Seconds",120,100);
    LCD.FillRectangle(75,160,75,30); 
     LCD.FillRectangle(155,160,75,30); 
     LCD.SetFontColor(BLACK);
     LCD.SetFontScale(0.5);
     //giving player option to play again or return to main menu
     LCD.WriteAt("Play Again",80,165);
    LCD.WriteAt("Main Menu",160,165);
    LCD.Update();

    //detecting touch
    int A,B,A2,B2; 
    while(!LCD.Touch(&A,&B)) {}; 
    while(LCD.Touch(&A2,&B2)) {}; 
    if(A>75&&A<150&&B>160&&B<210)
    {
         funccall.Difficulty();
    }

    else if(A>155&&A<230&&B>160&&B<210)
    {
        funccall.MainMenu();
    }
    // Clicked outside buttons - do nothing and return
    else
    {
        return;
    }
}  

//defining MainMenu function
void Stats::MainMenu() 
{ 
    FEHImage highstreet; // Screenshot from Google Earth 
    // Open the image 
    highstreet.Open("highstreetpic.png"); 
    LCD.Clear(); 
    //Diplaying 4 buttons with text for players options
    LCD.SetFontColor(LIGHTGOLDENRODYELLOW); 
    highstreet.Draw(0, 0); 
    LCD.FillRectangle(79, 47, 159, 35); 
    LCD.FillRectangle(79, 85,  159, 35 ); 
    LCD.FillRectangle( 79, 123, 159, 35 ); 
    LCD.FillRectangle( 79, 161, 159, 35 ); 
    LCD.SetFontColor(BLACK); 
    LCD.SetFontScale(1); 
    LCD.WriteAt("High Street Dash",64,20); 
    LCD.WriteAt("Credits",120,132); 
    LCD.WriteAt("Instructions",88,94); 
    LCD.WriteAt("Start",130,56); 
    LCD.SetFontScale(0.5); 
    LCD.WriteAt("Stats/Leaderboard",105,170); 
    LCD.Update(); 
    //detecting touch
    float x,y,x2,y2; 
       /* Wait until the user touches the screen */ 
    while(!LCD.Touch(&x,&y)) {}; 
        /* Wait until the touch releases */ 
    while(LCD.Touch(&x2,&y2)) {};  
    Touch(x,y); 
} 
//defining the Touch function
void Stats::Touch(int x, int y) 
{ 
    //navigating player based off which button they click
 if(x>79&&x<238&&y>47&&y<82) 
    { 
        //calling difficulty function
        Difficulty();
    }
    else if(x>79&&x<238&&y>85&&y<120) 
    { 
        //Displaying instructions
    LCD.Clear(); 
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Instructions:",50,50); 
    LCD.WriteAt("To play, click to move your character to the 3 ",20,70); 
    LCD.WriteAt("different paths. Ensure that you character does",20,90); 
    LCD.WriteAt("not collide with any obstacles. If you do collide,",20,110); 
    LCD.WriteAt("you lose. The goal is to last as long as you can.",20,130); 
    LCD.WriteAt("",50,130); 
    LCD.WriteAt("Good Luck! ",50,150); 
    LCD.Update(); 
    //Creating return to main menu button
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    else if(x>79&&x<238&&y>123&&y<158) 
  { 
    //displaying credits
   LCD.Clear(); 
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Credits:",50,50); 
    LCD.WriteAt("Made by Addison Painting and Nick Nahrwold",50,70); 
    LCD.WriteAt("SDP Project for FEH 1281H",50,90); 
    LCD.WriteAt("Prof: Dr. H Class 10:20am 12/1/2025",50,110); 
    LCD.Update(); 
    //Creating return to main menu button
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    else if(x>79&&x<238&&y>161&&y<196) 
    { 
    LCD.Clear(); 
    //calling function to display leaderboard
    funccall.writeleaderboard(&easyw,&medw,&hardw);
    //Creating return to main menu button
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    LCD.Update(); 
    //detecting touch
    int a,b,a2,b2; 
    while(!LCD.Touch(&a,&b)) {}; 
    while(LCD.Touch(&a2,&b2)) {}; 
    //determining if player clicked return button
    if (a>10&&a<150&&b>10&&b<25) 
    { 
        //returning to main menu
        funccall.MainMenu(); 
    } 
} 
//defining difficulty function
void Stats::Difficulty()
{
    LCD.Clear();
    //creating buttons for user to choose difficulty
    LCD.SetFontColor(RED);
    LCD.FillRectangle(79, 47, 159, 35); 
    LCD.FillRectangle(79, 85,  159, 35 ); 
    LCD.FillRectangle( 79, 123, 159, 35 ); 
    LCD.SetFontColor(WHITE);
    LCD.WriteAt("CHOOSE YOUR DIFFICULTY:",90,20);
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Easy Mode",130,56);
    LCD.WriteAt("Medium Mode",125,94); 
    LCD.WriteAt("Hard Mode",130,132); 
    LCD.Update();
    //detecting touch
     float x,y,xx,yy;     
    while(!LCD.Touch(&x,&y)) {}; 
    while(LCD.Touch(&xx,&yy)) {}; 
    //based on which button is clicked, a different difficulty value is passed to the game function and game function is called  
    if(x>79&&x<238&&y>47&&y<82)
    {
        Game(6);
    } 
     else if(x>79&&x<238&&y>85&&y<120)
    {
        Game(8);
    }
     else if(x>79&&x<238&&y>123&&y<158)
    {
        Game(10);
    } 
}
//defining writeleaderboard function
void Stats::writeleaderboard(int *ew,int *mw,int *hw)
{
    //displaying the highest time that was returned from each levels leaderboard function
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Displayed items:",50,50); 
    LCD.WriteAt("Longest Hard Difficulty Time :",50,70); 
    LCD.WriteAt("Longest Medium Difficulty Time :",50,90); 
    LCD.WriteAt("Longest Easy Difficulty Time :",50,110); 
    LCD.WriteAt(*hw ,230,70); 
    LCD.WriteAt(*mw ,242,90); 
    LCD.WriteAt(*ew ,230,110); 
    LCD.Update(); 
}
//defining the easyleaderboard function
void Stats::easyleaderboard(int e,int *ew)
{
    //testing if the users time is greater than the current highest
    if (e>easywinner)
    {
        //replacing highest time
        easywinner=e;
    }
    //storing high score in pointer user input
    *ew=easywinner;
}
//defining the medleaderboard function
void Stats::medleaderboard (int m, int *mw)
{
    //testing if the users time is greater than the current highest
    if (m>medwinner)
    {
        //replacing highest time
        medwinner=m;
    }
    //storing high score in pointer user input
    *mw=medwinner;
}
//defining the hardleaderboard function
void Stats::hardleaderboard (int h,int *hw)
{
    //testing if the users time is greater than the current highest
    if (h>hardwinner)
    {
         //replacing highest time
        hardwinner=h;
    }
    //storing high score in pointer user input
    *hw=hardwinner;
}

//main function
int main()
{
//creating a never ending loop that calls the MainMenu function that starts the game
   while(1)
   {
    funccall.MainMenu();
   
   }
}
