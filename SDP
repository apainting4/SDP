//including headers Nick Nahrwold  and Addison Painting
#include "FEHUtility.h"
#include "FEHLCD.h"
#include "FEHImages.h"
#include "FEHKeyboard.h"
#include <FEHRandom.h>
#include <stdio.h>
#include "FEHSound.h"

//Creating a class so all the data can be shared Addison Painting
class Stats {
public:
//Defining all the functions as public Addison Painting
void MainMenu(); 
void Touch(int a, int b);
void Game(int d);
void GameOver(int *t);
void Difficulty();
void writeleaderboard(int *ew,int *mw,int *hw);
void easyleaderboard(int e,int *ew);
void medleaderboard (int m, int *mw);
void hardleaderboard (int h, int *hw);

private:
//Declaring variables as private Addison Painting
int medw,hardw,easyw;
int easywinner=0;
int medwinner=0;
int hardwinner=0;
int time=0;
int difficulty;

//Declaring a variable of class Stats Addison Painting

}funccall;


//Struct for robot variables Nick Nahrwold
struct Robot {
    int xpos;
    int ypos;

    //bounding boxes for collisions Nick Nahrwold
    int topy;
    int boty;
    int leftx;
    int rightx;

    //rest bool condition Nick Nahrwold
    bool reset;
};


void Stats::Game(int d)
{
    //Clearing screen for game Addison painting
    LCD.Clear();
    LCD.Update();
    //Initializing start time Addison Painting
    int starttime=TimeNow();
    //Finding seconds passed
    time=TimeNow()-starttime;
    //Displaying seconds passed Addison Painting
   LCD.SetFontColor(WHITE);
   LCD.WriteAt(time,15,215); 

       int gameover = false;
    
    //declare the robots Nick Nahrwold
    struct Robot robot1;
    struct Robot robot2;
    struct Robot robot3;


    //variables Nick Nahrwold

            //brutus position Nick Nahrwold
            int positionx = 152;
            int positiony = 185;
            
            //brutus position variables Nick Nahrwold
            int right = 0;
            int rightcount = 0;

            //brutus position varibles Nick Nahrwold
            int left = 0;
            int leftcount = 0;

            //brutus bounds Nick Nahrwold
            int brutus_topy = positiony - 15;
            int brutus_boty = positiony + 15;
            int brutus_left = positionx - 10;
            int brutus_right = positionx + 10;

            //collisons Nick Nahrwold
            bool brutuscollision;

    //initial robot positions Nick Nahrwold
    robot1.xpos = 111;
    robot1.ypos = -200;
    robot1.leftx = robot1.xpos - 20;
    robot1.rightx = robot1.xpos + 20;
    robot1.topy = robot1.ypos - 15;
    robot1.boty = robot1.ypos + 15;

    robot2.xpos = 111;
    robot2.ypos = -300;
    robot2.leftx = robot2.xpos - 20;
    robot2.rightx = robot2.xpos + 20;
    robot2.topy = robot2.ypos - 15;
    robot2.boty = robot2.ypos + 15;

    robot3.xpos = 111;
    robot3.ypos = -400;
    robot3.leftx = robot3.xpos - 20;
    robot3.rightx = robot3.xpos + 20;
    robot3.topy = robot3.ypos - 15;
    robot3.boty = robot3.ypos + 15;

    //road y position variables Nick Nahrwold
    int road1y = 0;
    int road2y = -240;

    //highstreety Nick Nahrwold
    int high1y = -2726;
    int high2y = -5692;

    int ahigh1y = -2726;
    int ahigh2y = -5692;



    
    //difficulty **changes the speed of the game** Nick Nahrwold
   difficulty=d;

    //path random variable radmizor vairable for robot Nick Nahrwold
    int pathrand;

    //collision variable Nick Nahrwold
    bool collision = true; 

    FEHImage road1; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    road1.Open("road.png");

    FEHImage road2; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    road2.Open("road.png");

    FEHImage brutus; // AI generated image from chat gpt Nick Nahrwold
    // Open the image
    brutus.Open("brutus.png");  
   
    FEHImage robot; //AI generated image from chat gpt Nick Nahrwold
    // Open the image
    robot.Open("finalrobot.png");
    
    FEHImage highstreet1; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    highstreet1.Open("LONGWAYhighstreet.png");

    FEHImage highstreet2; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    highstreet2.Open("LONGWAYhighstreet.png");

    FEHImage ahighstreet1; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    ahighstreet1.Open("aLONGWAYhighstreet.png");

    FEHImage ahighstreet2; // Screenshot from Google Earth Nick Nahrwold
    // Open the image
    ahighstreet2.Open("aLONGWAYhighstreet.png");

    //draw initial position of the hightstreet moving out banners  Nick Nahrwold
    highstreet1.Draw(-9, -2726);
    highstreet1.Draw(-9, -5692);

    ahighstreet1.Draw(229, -2726);
    ahighstreet1.Draw(229, -5692);



    road1.Draw(110, 0);
    road2.Draw(110,-240);
    brutus.Draw(positionx, 185);
    LCD.Update();
    

    // Create and play a background music file Nick Nahrwold
    FEHSound backgroundMusic("Minion March.wav"); //This is from the game "Minion Rush"
    backgroundMusic.setVolume(0.5);
    backgroundMusic.play();
    
    

    while(gameover == false)
    {


// move right position function for brutus to slowly move him  Nick Nahrwold
    if(positionx < 188)
        {
        if(right != 1)
        {
        if(Keyboard.isPressed({KEY_D}))
            {
            right = 1;
            }
        }
        }
    if ((right) == 1)
        {
        if((rightcount) <  36)
                {
                positionx += 6;
                rightcount += 6;
                }
        
        else
                {
                right = 0;
                rightcount = 0;
                } 
        }


        Sleep(8);

//move left function for brutus to slowly move him  Nick Nahrwold
if(positionx > 116)
        {
        if(left != 1)
        {
        if(Keyboard.isPressed({KEY_A}))
            {
            left = 1;
            }
        }
        }
    if ((left) == 1)
        {
        if((leftcount) < 36)
                {
                positionx -= 6;
                leftcount += 6;
                }
        
        else
                {
                left = 0;
                leftcount = 0;
                } 
        }

    // increment road and high street position and draw them on top of previous images Nick Nahrwold
    high1y += difficulty;
    high2y += difficulty;

    ahigh1y += difficulty;
    ahigh2y += difficulty;

    road1y += difficulty;
    road2y += difficulty;

    road1.Draw(110, road1y);
    road2.Draw(110, road2y);

    highstreet1.Draw(-9, high1y);
    highstreet2.Draw(-9, high2y);

    ahighstreet1.Draw(229, ahigh1y);
    ahighstreet2.Draw(229, ahigh2y);


    //statements to move the backround back to the top of the screen once it fully exits the screen Nick Nahrwold
    if(road1y >= 240){
        road1y = -240;
    }
    if(road2y >= 240){
        road2y = -240;
    }

    if(high1y >= 2966){
        high1y = -2966;
    }
    if(high2y >= 2966){
        high2y = -2966;
    }

    if(ahigh1y >= 2966){
        ahigh1y = -2966;
    }
    if(ahigh2y >= 2966){
        ahigh2y = -2966;
    }
    
//robot 1 spawn in protocol Nick Nahrwold

    //set the robot back to above the screen if the robot goes off the screen Nick Nahrwold
    if(robot1.ypos > 260) 
    {
             
                    do{
                    robot1.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200) set this for random placement of robots Nick Nahrwold
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand){

                    case 1:
                        robot1.xpos = 111;//one of 3 x positions Nick Nahrwold
                    break;

                    case 2:
                        robot1.xpos = 149;//one of 3 x positions Nick Nahrwold
                    break;

                    case 3:
                        robot1.xpos = 183;//one of 3 x postions  Nick Nahrwold
                    break;


                    }   
                    //calculate bounding boxes and ensure that the robot is not colliding with any other robot for spawn in Nick Nahrwold
                    robot1.leftx = robot1.xpos - 20;
                    robot1.rightx = robot1.xpos + 20;
                    robot1.topy = robot1.ypos - 15;
                    robot1.boty = robot1.ypos + 15;

                        collision = false;

                        // robot1 vs robot2 collision check Nick Nahrwold
                        if (!(robot1.rightx < robot2.leftx  || robot1.leftx  > robot2.rightx || robot1.boty   < robot2.topy   || robot1.topy   > robot2.boty)){collision = true;}

                        // robot1 vs robot3 collision check  Nick Nahrwold
                        if (!(robot1.rightx < robot3.leftx  || robot1.leftx  > robot3.rightx || robot1.boty   < robot3.topy   || robot1.topy   > robot3.boty)){collision = true;}


                    
        } while(collision == true);
        collision = true;
        
    }

//robot 2 spawn in protocol Nick Nahrwold
 
    if(robot2.ypos > 260) //set the robot back to above the screen if the robot goes off the screen Nick Nahrwold
    {
    
                    do{
                    robot2.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200) set this for random placement of robots Nick Nahrwold
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand)
                        {

                        case 1:
                            robot2.xpos = 111;//one of 3 x postions  Nick Nahrwold
                        break;

                        case 2:
                            robot2.xpos = 149;//one of 3 x postions  Nick Nahrwold
                        break;

                        case 3:
                            robot2.xpos = 183;//one of 3 x postions  Nick Nahrwold 
                        break;

                        }   
                    //calculate bounding boxes and ensure that the robot is not colliding with any other robot for spawn in Nick Nahrwold
                    robot2.leftx = robot2.xpos - 20;
                    robot2.rightx = robot2.xpos + 20;
                    robot2.topy = robot2.ypos - 15;
                    robot2.boty = robot2.ypos + 15;

                        collision = false;

                        // robot1 vs robot2 collision check Nick Nahrwold
                        if (!(robot2.rightx < robot1.leftx  || robot2.leftx  > robot1.rightx || robot2.boty   < robot1.topy   || robot2.topy   > robot1.boty)){collision = true;}

                        // robot1 vs robot3 collision check  Nick Nahrwold
                        if (!(robot2.rightx < robot3.leftx  || robot2.leftx  > robot3.rightx || robot2.boty   < robot3.topy   || robot2.topy   > robot3.boty)){collision = true;}

 
                    
        } while(collision == true);
        collision = true;
        
    }

//robot 3 spawn in protocol Nick Nahrwold

    
    if(robot3.ypos > 260) //set the robot back to above the screen if the robot goes off the screen Nick Nahrwold
    {
                    
                    
                    
                    
                    do{
                    robot3.ypos = 20 * ((abs(Random.RandInt()) % 10) + 1) - 240;  //random number (20 - 200)   moved up above scree
                    pathrand = (Random.RandInt() % 3) + 1;   
                    switch(pathrand){

                    case 1:
                        robot3.xpos = 111;//one of 3 x postions  Nick Nahrwold
                    break;

                    case 2:
                        robot3.xpos = 149;//one of 3 x postions  Nick Nahrwold 
                    break;

                    case 3:
                        robot3.xpos = 183;//one of 3 x postions  Nick Nahrwold
                    break;


                    }   
                    //calculate bounding boxes and ensure that the robot is not colliding with any other robot for spawn in Nick Nahrwold
                    robot3.leftx = robot3.xpos - 20;
                    robot3.rightx = robot3.xpos + 20;
                    robot3.topy = robot3.ypos - 15;
                    robot3.boty = robot3.ypos + 15;

                        collision = false;

                        // robot1 vs robot2 collision check Nick Nahrwold
                        if (!(robot3.rightx < robot2.leftx  || robot3.leftx  > robot2.rightx || robot3.boty   < robot2.topy   || robot3.topy   > robot2.boty)){collision = true;}

                        // robot1 vs robot3 collision check  Nick Nahrwold
                        if (!(robot3.rightx < robot1.leftx  || robot3.leftx  > robot1.rightx || robot3.boty   < robot1.topy   || robot3.topy   > robot1.boty)){collision = true;}


                    
        } while(collision == true); // loop until collsion is not true (robot found a non colliding spot to spawn in) Nick Nahrwold
        collision = true;
        
    }

    //check for brutus collisions by calculating robot bounding boxes and brutus bounding boxes Nick Nahrwold

    robot1.leftx = robot1.xpos - 20;
    robot1.rightx = robot1.xpos + 20;
    robot1.topy = robot1.ypos - 15;
    robot1.boty = robot1.ypos + 15;

    robot2.leftx = robot2.xpos - 20;
    robot2.rightx = robot2.xpos + 20;
    robot2.topy = robot2.ypos - 15;
    robot2.boty = robot2.ypos + 15;

    robot3.leftx = robot3.xpos - 20;
    robot3.rightx = robot3.xpos + 20;
    robot3.topy = robot3.ypos - 15;
    robot3.boty = robot3.ypos + 15;

    brutus_topy = positiony - 15;
    brutus_boty = positiony + 15;
    brutus_left = positionx - 10;
    brutus_right = positionx + 10;

    brutuscollision = false;

                        //Check for collisions of brutus and robots Nick Nahrwold
                        if (!(brutus_right < robot1.leftx  || brutus_right  > robot1.rightx || brutus_boty   < robot1.topy   || brutus_topy   > robot1.boty)){brutuscollision = true;}

                        if (!(brutus_right < robot2.leftx  || brutus_right  > robot2.rightx || brutus_boty   < robot2.topy   || brutus_topy   > robot2.boty)){brutuscollision = true;}

                        if (!(brutus_right < robot3.leftx  || brutus_right  > robot3.rightx || brutus_boty   < robot3.topy   || brutus_topy   > robot3.boty)){brutuscollision = true;}
        

    


    ///advance robots with the difficulty increment Nick Nahrwold
    
    robot.Draw(robot1.xpos, robot1.ypos);
    robot1.ypos += difficulty;

    robot.Draw(robot2.xpos, robot2.ypos);
    robot2.ypos += difficulty;

    robot.Draw(robot3.xpos, robot3.ypos);
    robot3.ypos += difficulty;

    //draw brutus Nick Nahrwold
    brutus.Draw(positionx, 185);

    //updating timer
    LCD.SetFontColor(BLACK);
    LCD.FillRectangle(10, 210, 25, 20);
    time=TimeNow()-starttime;
   LCD.SetFontColor(WHITE);
   LCD.WriteAt(time,15,215);

    if(brutuscollision == true){
         gameover = true;
         backgroundMusic.pause();
      //Updating the high score based on difficulty level chosen Addison Painting
       if(difficulty==6)
      {
        
        funccall.easyleaderboard(time,&easyw);
      }
      else if(difficulty==8)
      {
       
        funccall.medleaderboard(time,&medw);
      }
      else if(difficulty==10)
      {
        
        funccall.hardleaderboard(time,&hardw);
      }
      //Displaying game over screen Addison Painting
      funccall.GameOver(&time);
    }

     
    
    LCD.Update();
    Sleep(10);
}
}
//defining GameOver function Addison Painting
void Stats::GameOver(int *t)
{
    FEHSound vineboom("vine-boom.wav"); //from "vineboom sound effect" Nick Nahrwold
    vineboom.setVolume(1);
    vineboom.play();
    LCD.Clear();
    LCD.SetFontColor(WHITE);
    LCD.SetFontScale(2);
    LCD.WriteAt("GAME OVER",50,25);
    //displaying players time that was passed to the function Addison painting
    LCD.SetFontScale(1);
    LCD.WriteAt("Player's Time:",70,80);
    LCD.WriteAt(*t,70,100);
    LCD.WriteAt("Seconds",120,100);
    LCD.FillRectangle(75,160,75,30); 
     LCD.FillRectangle(155,160,75,30); 
     LCD.SetFontColor(BLACK);
     LCD.SetFontScale(0.5);
     //giving player option to play again or return to main menu Addison Painting
     LCD.WriteAt("Play Again",80,165);
    LCD.WriteAt("Main Menu",160,165);
    LCD.Update();

    //detecting touch
    int A,B,A2,B2; 
    while(!LCD.Touch(&A,&B)) {}; 
    while(LCD.Touch(&A2,&B2)) {}; 
    if(A>75&&A<150&&B>160&&B<210)
    {
         funccall.Difficulty();
    }

    else if(A>155&&A<230&&B>160&&B<210)
    {
        funccall.MainMenu();
    }
    // Clicked outside buttons - do nothing and return
    else
    {
        return;
    }
}  

//defining MainMenu function Addison Painting
void Stats::MainMenu() 
{ 
  
    FEHImage highstreet; // Screenshot from Google Earth  Nick Nahrwold
    // Open the image 
    highstreet.Open("highstreetpic.png"); 
    LCD.Clear(); 

    FEHSound carefree("Carefree.wav"); //from "kevin macleod song: carefree" Nick Nahrwold
    carefree.setVolume(.5);
    carefree.play();

    //Diplaying 4 buttons with text for players options Addison Painting
    LCD.SetFontColor(LIGHTGOLDENRODYELLOW); 
    highstreet.Draw(0, 0); 
    LCD.FillRectangle(79, 47, 159, 35); 
    LCD.FillRectangle(79, 85,  159, 35 ); 
    LCD.FillRectangle( 79, 123, 159, 35 ); 
    LCD.FillRectangle( 79, 161, 159, 35 ); 
    LCD.SetFontColor(BLACK); 
    LCD.SetFontScale(1); 
    LCD.WriteAt("High Street Dash",64,20); 
    LCD.WriteAt("Credits",120,132); 
    LCD.WriteAt("Instructions",88,94); 
    LCD.WriteAt("Start",130,56); 
    LCD.SetFontScale(0.5); 
    LCD.WriteAt("Stats/Leaderboard",105,170); 
    LCD.Update(); 
    //detecting touch Addison Painting
    float x,y,x2,y2; 
    /* Wait until the user touches the screen */ 
    while(!LCD.Touch(&x,&y)) {}; 

    carefree.pause();

    /* Wait until the touch releases */ 
    while(LCD.Touch(&x2,&y2)) {};  

    Touch(x,y); 
} 
//defining the Touch function Addison Painting
void Stats::Touch(int x, int y) 
{ 
    //navigating player based off which button they click Addison Painting
 if(x>79&&x<238&&y>47&&y<82) 
    { 
        //calling difficulty function Addison Painting
        Difficulty();
    }
    else if(x>79&&x<238&&y>85&&y<120) 
    { 
        //Displaying instructions Addison Painting
    LCD.Clear(); 
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Instructions:",50,50); 
    LCD.WriteAt("To play, click to move your character to the 3 ",15,70); 
    LCD.WriteAt("different paths. Ensure that you character does",15,90); 
    LCD.WriteAt("not collide with any obstacles. If you do collide,",15,110); 
    LCD.WriteAt("you lose. The goal is to last as long as you can.",15,130); 
    LCD.WriteAt("Use key 'A' to move left and key 'D' to move right.",15,150); 
    LCD.WriteAt("",50,130); 
    LCD.WriteAt("Good Luck! ",50,170); 
    LCD.Update(); 
    //Creating return to main menu button Addison Painting
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    else if(x>79&&x<238&&y>123&&y<158) 
  { 
    //displaying credits Addison Painting
   LCD.Clear(); 
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Credits:",50,50); 
    LCD.WriteAt("Made by Addison Painting and Nick Nahrwold",20,70); 
    LCD.WriteAt("SDP Project for FEH 1281H",20,90); 
    LCD.WriteAt("Prof: Dr. H Class 10:20am 12/1/2025",20,110); 
    LCD.WriteAt("Street Images from GOOGLE EARTH",20,130); 
    LCD.WriteAt("Robots and Brutus generated from CHAT GPT",20,150); 
    LCD.WriteAt("Music from stock audio library and Minion Rush",20,170); 
    LCD.WriteAt("Carefree from 'kevin macleod'",20,190); 

    LCD.Update(); 
    //Creating return to main menu button Addison painting
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    else if(x>79&&x<238&&y>161&&y<196) 
    { 
    LCD.Clear(); 
    //calling function to display leaderboard with updated stats Addison Painting
    funccall.writeleaderboard(&easyw,&medw,&hardw);
    //Creating return to main menu button Addison Painting
    LCD.FillRectangle( 10, 10, 150, 25 ); 
    LCD.SetFontScale(0.5); 
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Return to Main Menu",15,15); 
    } 
    LCD.Update(); 
    //detecting touch Addison Painting
    int a,b,a2,b2; 
    while(!LCD.Touch(&a,&b)) {}; 
    while(LCD.Touch(&a2,&b2)) {}; 
    //determining if player clicked return button Addison Painting
    if (a>10&&a<150&&b>10&&b<25) 
    { 
        //returning to main menu Addison Painting
        funccall.MainMenu(); 
    } 
} 
//defining difficulty function Addison Painting
void Stats::Difficulty()
{
    LCD.Clear();
    //creating buttons for user to choose difficulty Addison Painting
    LCD.SetFontColor(RED);
    LCD.FillRectangle(79, 47, 159, 35); 
    LCD.FillRectangle(79, 85,  159, 35 ); 
    LCD.FillRectangle( 79, 123, 159, 35 ); 
    LCD.SetFontColor(WHITE);
    LCD.WriteAt("CHOOSE YOUR DIFFICULTY:",90,20);
    LCD.SetFontColor(BLACK); 
    LCD.WriteAt("Easy Mode",130,56);
    LCD.WriteAt("Medium Mode",125,94); 
    LCD.WriteAt("Hard Mode",130,132); 
    LCD.Update();
    //detecting touch Addison Painting
     float x,y,xx,yy;     
    while(!LCD.Touch(&x,&y)) {}; 
    while(LCD.Touch(&xx,&yy)) {}; 
    //based on which button is clicked, a different difficulty value is passed to the game function and game function is called Addison Painting
    if(x>79&&x<238&&y>47&&y<82)
    {
        Game(6);
    } 
     else if(x>79&&x<238&&y>85&&y<120)
    {
        Game(8);
    }
     else if(x>79&&x<238&&y>123&&y<158)
    {
        Game(10);
    } 
}
//defining writeleaderboard function Addison Painting
void Stats::writeleaderboard(int *ew,int *mw,int *hw)
{
    //displaying the highest time that was returned from each levels leaderboard function Addison Painting
    LCD.SetFontColor(WHITE); 
    LCD.WriteAt("Displayed items:",50,50); 
    LCD.WriteAt("Longest Hard Difficulty Time :",50,70); 
    LCD.WriteAt("Longest Medium Difficulty Time :",50,90); 
    LCD.WriteAt("Longest Easy Difficulty Time :",50,110); 
    LCD.WriteAt(*hw ,230,70); 
    LCD.WriteAt(*mw ,242,90); 
    LCD.WriteAt(*ew ,230,110); 
    LCD.Update(); 
}
//defining the easyleaderboard function Addison Painting
void Stats::easyleaderboard(int e,int *ew)
{
    //testing if the users time is greater than the current highest Addison Painting
    if (e>easywinner)
    {
        //replacing highest time Addison Painting
        easywinner=e;
    }
    //storing high score in pointer user input Addison Painting
    *ew=easywinner;
}
//defining the medleaderboard function Addison Painting
void Stats::medleaderboard (int m, int *mw)
{
    //testing if the users time is greater than the current highest Addison Painting
    if (m>medwinner)
    {
        //replacing highest time Addison Painting
        medwinner=m;
    }
    //storing high score in pointer user input Addison Painting
    *mw=medwinner;
}
//defining the hardleaderboard function Addison Painting
void Stats::hardleaderboard (int h,int *hw)
{
    //testing if the users time is greater than the current highest Addison Painting
    if (h>hardwinner)
    {
         //replacing highest time Addison Painting
        hardwinner=h;
    }
    //storing high score in pointer user input Addison Painting
    *hw=hardwinner;
}

//main function Addison Painting
{
//creating a never ending loop that calls the MainMenu function that starts the game Addison Painting
   while(1)
   {
    funccall.MainMenu();
   
   }
}
